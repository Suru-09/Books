# Questions

## Homework description

- This program, process-run.py, allows you to see how process states change as program run and either use the CPU(e.g perform an add instruction) or do I/O (e.g. send a request to a disk and wait for it to complete). See the README for details.

## The actual questions

1. Run process-run.py with the following flags: -1 5:100,5:100.What should the CPU utilization be(e.g. the percent of time the CPU is in use?) Why do you know this? Use the -c and -p flags to see if you were right.
    The processor should be in 100% because there is no I/O running because of the 100% for both processes, changing the second one to 75% would result in a 68.75% busy cpu as described by -c -p flags.
2. Now run with these flags ./process-run.py -l 4:100, 1:0. These flags specify one process with 4 instructions (all to use the CPU), and one that simply issues an I/O and awaits for it to be done. How long does it take to complete both processes?
    Logically, the time it takes is the 4 clocks for the instructions of the first PROCESS, however do we know how many clocks does the I/O take? Don't think so, running it with -c -p results in Total time: 11 which is pretty weird.
3. Switch the order of the processes: -l 1:0,4:100. What happens now?Does switching the order matter? Why? (As always, use -c and -p to see if you were right).
    - **My answer:** I would say that the order does not matter, because we will wait for the P0 to finish and then start P1, however the same time should be taken in both scenarios:
    - **Correct Answer:** If the first process which has no I/O starts running first then our   dumb scheduler won't give control to the other process until its finished. However, if the second one runs once the I/O blocks the state of the process becomes BLOCKED and the other process starts running until it finishes. This way while the I/O is being handled the second process runs resulting in a time of 7 compared to 11 before.
4. We'll now explore some of the other flags. One important flag is -S, which determines how the system reacts when a process issues an I/O. With the flags set to SWTCH_ON_END, the system will NOT switch to another process while one is doing I/O, instead waiting untill the process is completely finished. What happens when you run the following two processes (l 1:0,4:100 -c S SWITCH_ON_END), one doing I/O and the other doing CPU work?
   The result will be the same as in Q2 even though P0 is the one initiating the I/O which is like in Q3. Thus, resulting in time of 11 instead of 7.
5. Now, run the same processes, but with the switching behavior set to switch to another process whenever one is WATING for I/O(-l 1:0,4:100 -c -S SWITCH_ON_IO).
    - The result is that immediately after the I/O starts blocking the second process(P1) starts running making it way more efficient.
6. One other important behavior is what to do when an I/O completes. With -I IO_RUN_LATER, when an I/O completes, the process that issued it is not necesarilly run right away; rather whatever was running at the time keeps runnings. What happens when you run this combination of processes? (./process-run.py -l 3:0, 5:100,5:100,5:100 -S SWITCH_ON_IO -c -p -I IO_RUN_LATER). Are system resources being effectively utilized?
   - The system resources are NOT utilized effectively because we have 3 I/O operations, if we were to switch on the I/O once the first completed we could block, start the I/O and continue with the other processes resulting in a time of 21 instead of 31(21 is the result of using IO_RUN_IMMEDIATE).

7. Now run the same processes, but wioth -I IO_RUN_IMMEDIATE set, which immediately ruyns the process that issued the I/O. How does this behavior differ? Why might running a process that just completed an I/O again be a good idea?
    - I basically answered this in Q6..
8. Now run some randomly generated processes using flags -s 1 -l 3:50,3:50 or -s 2 -l 3:50,3:50 or -s 3 -l 3:50,3:50. See if you can predict how the trace will turn out. What happens when you use the flag -I IO_RUN_IMMEDIATE versus that flag -I IO_RUN_LATER? What happens when you use the flag -S SWTICH_ON_IO versus -S SWITCH_ON_END?
    - **RUNNING them without additional flags:** Depending on the given seed one of {1, 2, 3} the number of I/O varies and we have a total between 15-18 CPU clocks of time.
    - **RUNNING with -I IO_RUN_IMMEDIATE:** I can see an improvement when the seed is {3} with one CPU clock faster.
     **RUNNING with -I IO_RUN_LATER:** The same as initially.
